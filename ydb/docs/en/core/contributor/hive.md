# Hive

Hive is a tablet responsible for managing other tablets, that is selecting nodes for them to run on, deciding to rebalance tablets, etc.

The creation and deletion of tablets is initiated by the [SchemeShard](../concepts/glossary.md#scheme-shard) tablet. When a tablet is created, Hive assigns it a unique TabletId, fills in [TabletStorageInfo](general-schema.md#history), selects the most suitable node, and sends a command to start the tablet on that node. In some abnormal situations, a tablet may interrupt its operation, in which case the node on which it was running sends a message to Hive. Hive also assumes that if the connection with a certain node is lost, the tablets running on it have stopped. In such cases, Hive restarts the tablets on other nodes, increasing the generation.

In a {{ ydb-short-name }} cluster, there is a root Hive responsible for the [system tablets](../concepts/glossary.md#tablet-types) of all databases in the cluster. The Hive of a specific database, in turn, is responsible for the tablets servicing the user load of that database. All nodes in the cluster are registered in the root Hive, while only the compute nodes of a specific database are registered in that database's Hive. When a node registers, it informs Hive of the types of tablets and the number of tablets that can be run on it.

## Resource usage metrics

To distribute tablets across nodes, Hive takes resource usage into account. For each tablet, the usage of four types of resources is tracked:

1. *CPU* — processor consumption, is calculated as the number of microseconds spent on tablet work in the last second, and converted to fractions of a core for visualisation.
2. *Memory* — the amount of RAM consumed by the tablet.
3. *Network* — the amount of traffic generated by the tablet.
4. *Counter* — a fake resource used to implement even distribution of tablets. If a tablet has a non-zero consumption of any other resource, its Counter value is 0; otherwise, it is 1. This way, Counter is used for any tablets for which there is no data on real consumption, as well as for tablets where real consumption tracking is disabled: by default, this applies only to [columnar tables](../concepts/datamodel/table.md#column-oriented-tables).

Additionally, to determine overloaded nodes, metrics of resource usage for the node as a whole are used: memory consumption and processor resources in the actor system thread pools. These values are converted into a relative value (a number from 0 to 1), and their maximum is used as the node's overall resource consumption value — *Node usage*. Also, Hive applies aggregation over a window to all metrics in order to account for load spikes.

Resource usage information is used for selecting a node for a tablet: for example, if only the CPU consumption of a tablet is known, the slected node will be among thos with the least CPU load. If there is data on multiple resources, the maximum of their relative usage values is used.


## Autobalancing

At certain moments, Hive may start an auto-balancing process that moves tablets between nodes to improve load distribution. The situations in which this occurs are listed below. The auto-balancer works iteratively, making decisions about moving tablets one at a time. It selects the most loaded node, chooses a tablet on it using weighted random, and finds a more suitable node for it. This process is repeated until balance is restored. The way node load is determined depends on the type of balancing: for example, in case of CPU consumption imbalance, CPU usage is used, while for uneven distribution of columnar tables, the number of tablets is used instead.

### Resource usage imbalance

To quantify the balance of resource usage, Hive uses the *Scatter* metric, which is calculated separately for each resource using the following formula:

$$\mathrm{Scatter} = \frac{\mathrm{MaxUsage} - \mathrm{MinUsage}}{\mathrm{MaxUsage}}$$

$\mathrm{MaxUsage}$ and $\mathrm{MinUsage}$ are respectively the maximum and minimum usage of a resource across all nodes. To normalize consumption on each node, the number of available resources on the node is used, which may vary between nodes. Under low loads, this metric may fluctuate significantly. To avoid this, when calculating $\mathrm{Scatter}$, it is assumed that resource usage cannot be lower than 30%. Balancer is triggered if $Scatter$ exceeds a threshold.


The maximum value of $Scatter$ across different resources is available as the [sensor](../devops/manual/monitoring.md) `Hive/MAX(BalanceScatter)` in the `tablets` subgroup.

### Node overload

The presence of an overloaded node can negatively affect the performance of {{ ydb-short-name }}: CPU overload leads to starvation and increased latency, while memory overload can cause the node to crash wth an out-of-memory error. Balancer is triggered if the load of the most loaded node exceeds 90%, and the load of the least loaded node is below 70%.

The maximum usage on a node is available as the [sensor](../devops/manual/monitoring.md) `Hive/MAX(BalanceUsageMax)` in the `tablets` subgroup.

### Even distribution for a specific object

For tablets that use the Counter resource, the evenness of the distribution of tablets for each object (each table) is tracked using the `ObjectImbalance` metric, similar to the $Scatter$ described above. During node restarts, the evenness may be disrupted, and balancing is triggered in such cases.

The maximum value of `ObjectImbalance` across different objects is available as the [sensor](../devops/manual/monitoring.md) `Hive/MAX(BalanceObjectImbalance)` in the `tablets` subgroup.

